<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Javascript Cheatsheet</title>

    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <a href="index.html">HTML</a>
        <a href="css.html">CSS</a>
        <a href="javascript.html">Javascript</a>
    </nav>
    <h1>Data Types</h1>
    <dl>
        <dt>String</dt>
        <dd>text data enclosed with quotes. <pre>let myString = 'My String'</pre></dd>
        <dt>Number</dt>
        <dd>Number data that can be modified with <a href="#">primitive operators</a>.</dd>
    </dl>
    <h1>Variables</h1>
    <dl>
        <dt>var</dt>
        <dd>Function-scope variable that can be accessed throughout a function. <pre>var myVariable = 'Function-scope'</pre></dd>
        <dt>let</dt>
        <dd>Block-scoped variable that can be accessed within the {} but not outside of it. Let signals that the value can be changed. <pre>let myVariable = 'block-scope'</pre></dd>
        <dt>const</dt>
        <dd>Constant variable. The value cannot be reassigned. Constant variables must be assigned a value when the variable is declared <pre>const myVariable = 'Cannot be changed'</pre></dd>
    </dl>
    <h1>Operators</h1>
    <dl>
        <dt id="primitiveOperators">Primitive operators</dt>
        <dd>Basic math operators. Addition = +, Subtraction = -, multiplication = *, division = /</dd>
        <dt>Mathematical assignment operators</dt>
        <dd>Combines a <a href="#primitiveOperators">primitive operator</a> with the value assignment operator '=" <pre>let x = 20
            x -= 5 // Can be written as x = x - 5
            console.log(x) // Output: 15
             
            let y = 50
            y *= 2 // Can be written as y = y * 2
            console.log(y) // Output: 100</pre></dd>
        <dt>The Increment and Decrement Operator</dt>
        <dd>The increment operator will increase the value of the variable by 1. The decrement operator will decrease the value of the variable by 1. <pre>let a = 10
            a++
            console.log(a) // Output: 11
            let b = 20
            b--
            console.log(b) // Output: 19</pre></dd>
        <dt>String Interpolation</dt>
        <dd>Insert, or interpolate, variables into strings using template literals. Template literals are enclosed by backticks ` and allow you to insert a variable without escaping and entering multiple strings.
            <pre>const myPet = 'armadillo'
            console.log(`I own a pet ${myPet}.`)
            // Output: I own a pet armadillo.</pre></dd>
        <dt>ypeof Operator</dt>
        <dd> If you need to check the data type of a variable’s value, you can use the typeof operator. The typeof operator checks the value to its right and returns, or passes back, a string of the data type.
            <pre>const unknown1 = 'foo';
                console.log(typeof unknown1); // Output: string
                 
                const unknown2 = 10;
                console.log(typeof unknown2); // Output: number
                 
                const unknown3 = true; 
                console.log(typeof unknown3); // Output: boolean</pre>
        </dd>
       
    </dl>
    <h1>Conditional Statements</h1>
    <dl>
        <dt>Conditional Statements</dt>
        <dd>checks a specific condition(s) and performs a task based on the condition(s)</dd>
        <dt>If Statement</dt>
        <dd>The if keyword followed by a set of parentheses () which is followed by a code block, or block statement, indicated by a set of curly braces {}.
            Inside the parentheses (), a condition is provided that evaluates to true or false.
            If the condition evaluates to true, the code inside the curly braces {} runs, or executes.
            If the condition evaluates to false, the block won’t execute.<pre>if (true) {
                console.log('This message will print!'); 
            }
            // Prints: This message will print!</pre></dd>
            <dt>If...Else Statements</dt>
            <dd>Uses the else keyword following the code block of an if statement.
                Has a code block that is wrapped by a set of curly braces {}.
                The code inside the else statement code block will execute when the if statement’s condition evaluates to false.<pre>if (false) {
                    console.log('The code in this block will not run.');
                } else {
                    console.log('But the code in this block will!');
                }
                
                // Prints: But the code in this block will!</pre>
            </dd>
            <dt>Comparison Operators</dt>
            <dd>
                <ul>
                    <li>Less than: <</li>
                    <li>Greater than: ></li>
                    <li>Less than or equal to: <=</li>
                    <li>Greater than or equal to: >=</li>
                    <li>Is equal to: ===</li>
                    <li>Is not equal to: !==</li>
                </ul>
                <pre>10 < 12 // Evaluates to true</pre>
            </dd>
            <dt>Logical Operators</dt>
            <dd>
                <ul>
                    <li>the and operator (&&)<br>When using the && operator, both conditions must evaluate to true for the entire condition to evaluate to true and execute. Otherwise, if either condition is false, the && condition will evaluate to false and the else block will execute.<pre>if (stopLight === 'green' && pedestrians === 0) {
                        console.log('Go!');
                      } else {
                        console.log('Stop');
                      }</pre></li>
                    <li> the or operator (||)<br>When using the || operator, only one of the conditions must evaluate to true for the overall statement to evaluate to true.<pre>if (day === 'Saturday' || day === 'Sunday') {
                        console.log('Enjoy the weekend!');
                      } else {
                        console.log('Do some work.');
                      }</pre></li>
                    <li>the not operator, otherwise known as the bang operator (!)<br>The ! not operator reverses, or negates, the value of a boolean. Essentially, the ! operator will either take a true value and pass back false, or it will take a false value and pass back true.<pre>let excited = true;
                        console.log(!excited); // Prints false
                         
                        let sleepy = false;
                        console.log(!sleepy); // Prints true</pre></li>
                </ul>
            </dd>
            <dt>Truthy and Falsy</dt>
            <dd>Only checks to see if the variable has been assigned a non-falsy value.<br>
            falsey values include:
                <ul>
                    <li>0</li>
                    <li>Empty strings like "" or ''</li>
                    <li>null which represent when there is no value at all</li>
                    <li>undefined which represent when a declared variable lacks a value</li>
                    <li>NaN, or Not a Number</li>
                </ul>
                <pre>let numberOfApples = 0;
 
                    if (numberOfApples){
                       console.log('Let us eat apples!');
                    } else {
                       console.log('No apples left!');
                    }
                     
                    // Prints 'No apples left!'</pre>
        </dd>
        <dt>Ternary Operator</dt>
        <dd>A ternary operator can simplify an if...else statement.
          
            <pre>let isNightTime = true;
 
            if (isNightTime) {
              console.log('Turn on the lights!');
            } else {
              console.log('Turn off the lights!');
            }</pre>
        can be refactored as <pre>isNightTime ? console.log('Turn on the lights!') : console.log('Turn off the lights!');</pre>
            <ul>
                <li>The condition, isNightTime, is provided before the ?.</li>
                <li>Two expressions follow the ? and are separated by a colon :</li>
                <li>If the condition evaluates to true, the first expression executes</li>
                <li>If the condition evaluates to false, the second expression executes</li>
            </ul>
            In the above example the statement only checks if the variable isNightTime has a non-falsey value. If you want to check if a value matches something exactly you can add comparison operators to the ternary statement:
            <pre>let favoritePhrase = 'Love That!';

                if (favoritePhrase === 'Love That!') {
                  console.log('I love that!');
                } else {
                  console.log("I don't love that!");
                }</pre>
            refactors to 
            <pre>
                let favoritePhrase = 'Love That!';
                favoritePhrase === 'Love That!' ? console.log('I love that!') : console.log("I don't love that!");
            </pre>
         </dd>
         <dt>Else/if statements</dt>
         <dd>After an if statement multiple else/if statements can be added to create various outcoumes.<pre>let groceryItem = 'papaya';
 
            if (groceryItem === 'tomato') {
              console.log('Tomatoes are $0.49');
            } else if (groceryItem === 'papaya'){
              console.log('Papayas are $1.29');
            } else {
              console.log('Invalid item');
            }</pre></dd>
        <dt>The Switch Keyword</dt>
        <dd><p>A shorthand for else/if statements. The switch statements provide a means of checking an expression against multiple case clauses. If a case matches, the code inside that clause is executed.</p>

            <p>The case clause should finish with a break keyword. If no case matches but a default clause is included, the code inside default will be executed.</p>
            
            <p>Note: If break is omitted from the block of a case, the switch statement will continue to check against case values until a break is encountered or the flow is broken.</p>
            <pre>const food = 'salad';
 
                switch (food) {
                  case 'oyster':
                    console.log('The taste of the sea 🦪');
                    break;
                  case 'pizza':
                    console.log('A delicious pie 🍕');
                    break;
                  default:
                    console.log('Enjoy your meal');
                }
                 
                // Prints: Enjoy your meal</pre>
        </dd>
        </dl>
        <h1>Functions</h1>
        <dl>
          <dt>Functions</dt>
          <dd>Functions are reusable blocks of code that groups a sequence of statements together to exeecute a specific task</dd>
        </dl>
        <dt>Function Declatation</dt>
        <dd>A function declaration binds a function to a name, or an identifier.<br>
          A function declaration consists of:
          <ul>
            <li>the function keyword </li>
            <li>the name of the function followed by parentheses</li>
            <li>A function body, or the block of statements required to perform a specific task, enclosed in the function’s curly brackets, { }</li>
          </ul>
          <pre>
            function greetWorld() {
              console.log('Hello, World!');
              greetWorld(); // Output: Hello, World!
            }</pre>
        </dd>
        <dt>Calling a Function</dt>
        <dd>To call a function in your code, you type the function name followed by parentheses. The function call executes the function body, or all of the statements between the curly braces in the function declaration.</dd>
        <dt>Parameters and Arguments</dt>
        <dd>Parameters allow functions to accept input(s) and perform a task using the input(s). We use parameters as placeholders for information that will be passed to the function when it is called. When declaring a function add the names of the input values in the parentheses. When calling the function fill the values in in the parentheses to be passed to the function when it runs. <pre>function sayThanks(name) {
          console.log('Thank you for your purchase '+ name + '! We appreciate your business.');
        }
        sayThanks('Cole')</pre></dd>
        <dt>Default Parameters</dt>
        <dd>Default parameters allow parameters to have a predetermined value in case there is no argument passed into the function or if the argument is undefined when called. The = operator to assign the parameter name a default value<pre>function greeting (name = 'stranger') {
          console.log(`Hello, ${name}!`)
        }
         
        greeting('Nick') // Output: Hello, Nick!
        greeting() // Output: Hello, stranger!</pre></dd>
        <dt>Return</dt>
        <dd>Return passes information back from the function call. Without returning the value it will remain undefined even though the function calculated the input arguments correctly.<pre>function rectangleArea(width, height) {
          if (width < 0 || height < 0) {
            return 'You need positive integers to calculate area!';
          }
          return width * height;
        }</pre></dd>
        <dt>Helper Functions</dt>
        <dd>Helper functions return the value of another function within a function. This way we can use functions to break down logic into smaller, more manageable pieces and reuse them later. <pre>function multiplyByNineFifths(number) {
          return number * (9/5);
        };
         
        function getFahrenheit(celsius) {
          return multiplyByNineFifths(celsius) + 32;
        };
         
        getFahrenheit(15); // Returns 59</pre></dd>
        <dt>Function Expressions</dt>
        <dd>To define a function inside an expression, we can use the function keyword. In a function expression, the function name is usually omitted. A function with no name is called an anonymous function. A function expression is often stored in a variable in order to refer to it.<pre>const plantNeedsWater = function(day) {
          if (day === 'Wednesday') {
            return true;
          } else {
            return false;
          }
        }
        console.log(plantNeedsWater('Wednesday'))</pre></dd>
        <dt>Arrow Functions</dt>
        <dd>Arrow functions remove the need to type out the keyword function every time you need to create a function. Instead, you first include the parameters inside the ( ) and then add an arrow => that points to the function body surrounded in { } like this:</dd>
        <dt>Concise Body Arrow Functions</dt>
        <dd>
          <ul>
            <li>Functions that take only a single parameter do not need that parameter to be enclosed in parentheses. However, if a function takes zero or multiple parameters, parentheses are required.</li>
            <li>A function body composed of a single-line block does not need curly braces. Without the curly braces, whatever that line evaluates will be automatically returned. The contents of the block should immediately follow the arrow => and the return keyword can be removed. This is referred to as implicit return.</li>
          </ul>
          <pre>const squareNum = (num) => {
            return num * num;
          };</pre>
          refactors to 
          <pre>const squareNum = num => num * num;</pre>
        </dd>
</body>
</html>