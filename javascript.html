<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Javascript Cheatsheet</title>

    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <a href="index.html">HTML</a>
        <a href="css.html">CSS</a>
        <a href="javascript.html">Javascript</a>
    </nav>
    <h1>Data Types</h1>
    <dl>
        <dt>String</dt>
        <dd>text data enclosed with quotes. <pre>let myString = 'My String'</pre></dd>
        <dt>Number</dt>
        <dd>Number data that can be modified with <a href="#">primitive operators</a>.</dd>
    </dl>
    <h1>Variables</h1>
    <dl>
        <dt>var</dt>
        <dd>Function-scope variable that can be accessed throughout a function. <pre>var myVariable = 'Function-scope'</pre></dd>
        <dt>let</dt>
        <dd>Block-scoped variable that can be accessed within the {} but not outside of it. Let signals that the value can be changed. <pre>let myVariable = 'block-scope'</pre></dd>
        <dt>const</dt>
        <dd>Constant variable. The value cannot be reassigned. Constant variables must be assigned a value when the variable is declared <pre>const myVariable = 'Cannot be changed'</pre></dd>
    </dl>
    <h1>Operators</h1>
    <dl>
        <dt id="primitiveOperators">Primitive operators</dt>
        <dd>Basic math operators. Addition = +, Subtraction = -, multiplication = *, division = /</dd>
        <dt>Mathematical assignment operators</dt>
        <dd>Combines a <a href="#primitiveOperators">primitive operator</a> with the value assignment operator '=" <pre>let x = 20
            x -= 5 // Can be written as x = x - 5
            console.log(x) // Output: 15
             
            let y = 50
            y *= 2 // Can be written as y = y * 2
            console.log(y) // Output: 100</pre></dd>
        <dt>The Increment and Decrement Operator</dt>
        <dd>The increment operator will increase the value of the variable by 1. The decrement operator will decrease the value of the variable by 1. <pre>let a = 10
            a++
            console.log(a) // Output: 11
            let b = 20
            b--
            console.log(b) // Output: 19</pre></dd>
        <dt>String Interpolation</dt>
        <dd>Insert, or interpolate, variables into strings using template literals. Template literals are enclosed by backticks ` and allow you to insert a variable without escaping and entering multiple strings.
            <pre>const myPet = 'armadillo'
            console.log(`I own a pet ${myPet}.`)
            // Output: I own a pet armadillo.</pre></dd>
        <dt>typeof Operator</dt>
        <dd> If you need to check the data type of a variable‚Äôs value, you can use the typeof operator. The typeof operator checks the value to its right and returns, or passes back, a string of the data type.
            <pre>const unknown1 = 'foo';
                console.log(typeof unknown1); // Output: string
                 
                const unknown2 = 10;
                console.log(typeof unknown2); // Output: number
                 
                const unknown3 = true; 
                console.log(typeof unknown3); // Output: boolean</pre>
        </dd>
       
    </dl>
    <h1>Conditional Statements</h1>
    <dl>
        <dt>Conditional Statements</dt>
        <dd>checks a specific condition(s) and performs a task based on the condition(s)</dd>
        <dt>If Statement</dt>
        <dd>The if keyword followed by a set of parentheses () which is followed by a code block, or block statement, indicated by a set of curly braces {}.
            Inside the parentheses (), a condition is provided that evaluates to true or false.
            If the condition evaluates to true, the code inside the curly braces {} runs, or executes.
            If the condition evaluates to false, the block won‚Äôt execute.<pre>if (true) {
                console.log('This message will print!'); 
            }
            // Prints: This message will print!</pre></dd>
            <dt>If...Else Statements</dt>
            <dd>Uses the else keyword following the code block of an if statement.
                Has a code block that is wrapped by a set of curly braces {}.
                The code inside the else statement code block will execute when the if statement‚Äôs condition evaluates to false.<pre>if (false) {
                    console.log('The code in this block will not run.');
                } else {
                    console.log('But the code in this block will!');
                }
                
                // Prints: But the code in this block will!</pre>
            </dd>
            <dt>Comparison Operators</dt>
            <dd>
                <ul>
                    <li>Less than: <</li>
                    <li>Greater than: ></li>
                    <li>Less than or equal to: <=</li>
                    <li>Greater than or equal to: >=</li>
                    <li>Is equal to: ===</li>
                    <li>Is not equal to: !==</li>
                </ul>
                <pre>10 < 12 // Evaluates to true</pre>
            </dd>
            <dt>Logical Operators</dt>
            <dd>
                <ul>
                    <li>the and operator (&&)<br>When using the && operator, both conditions must evaluate to true for the entire condition to evaluate to true and execute. Otherwise, if either condition is false, the && condition will evaluate to false and the else block will execute.<pre>if (stopLight === 'green' && pedestrians === 0) {
                        console.log('Go!');
                      } else {
                        console.log('Stop');
                      }</pre></li>
                    <li> the or operator (||)<br>When using the || operator, only one of the conditions must evaluate to true for the overall statement to evaluate to true.<pre>if (day === 'Saturday' || day === 'Sunday') {
                        console.log('Enjoy the weekend!');
                      } else {
                        console.log('Do some work.');
                      }</pre></li>
                    <li>the not operator, otherwise known as the bang operator (!)<br>The ! not operator reverses, or negates, the value of a boolean. Essentially, the ! operator will either take a true value and pass back false, or it will take a false value and pass back true.<pre>let excited = true;
                        console.log(!excited); // Prints false
                         
                        let sleepy = false;
                        console.log(!sleepy); // Prints true</pre></li>
                </ul>
            </dd>
            <dt>Truthy and Falsy</dt>
            <dd>Only checks to see if the variable has been assigned a non-falsy value.<br>
            falsey values include:
                <ul>
                    <li>0</li>
                    <li>Empty strings like "" or ''</li>
                    <li>null which represent when there is no value at all</li>
                    <li>undefined which represent when a declared variable lacks a value</li>
                    <li>NaN, or Not a Number</li>
                </ul>
                <pre>let numberOfApples = 0;
 
                    if (numberOfApples){
                       console.log('Let us eat apples!');
                    } else {
                       console.log('No apples left!');
                    }
                     
                    // Prints 'No apples left!'</pre>
        </dd>
        <dt>Ternary Operator</dt>
        <dd>A ternary operator can simplify an if...else statement.
          
            <pre>let isNightTime = true;
 
            if (isNightTime) {
              console.log('Turn on the lights!');
            } else {
              console.log('Turn off the lights!');
            }</pre>
        can be refactored as <pre>isNightTime ? console.log('Turn on the lights!') : console.log('Turn off the lights!');</pre>
            <ul>
                <li>The condition, isNightTime, is provided before the ?.</li>
                <li>Two expressions follow the ? and are separated by a colon :</li>
                <li>If the condition evaluates to true, the first expression executes</li>
                <li>If the condition evaluates to false, the second expression executes</li>
            </ul>
            In the above example the statement only checks if the variable isNightTime has a non-falsey value. If you want to check if a value matches something exactly you can add comparison operators to the ternary statement:
            <pre>let favoritePhrase = 'Love That!';

                if (favoritePhrase === 'Love That!') {
                  console.log('I love that!');
                } else {
                  console.log("I don't love that!");
                }</pre>
            refactors to 
            <pre>
                let favoritePhrase = 'Love That!';
                favoritePhrase === 'Love That!' ? console.log('I love that!') : console.log("I don't love that!");
            </pre>
         </dd>
         <dt>Else/if statements</dt>
         <dd>After an if statement multiple else/if statements can be added to create various outcoumes.<pre>let groceryItem = 'papaya';
 
            if (groceryItem === 'tomato') {
              console.log('Tomatoes are $0.49');
            } else if (groceryItem === 'papaya'){
              console.log('Papayas are $1.29');
            } else {
              console.log('Invalid item');
            }</pre></dd>
        <dt>The Switch Keyword</dt>
        <dd><p>A shorthand for else/if statements. The switch statements provide a means of checking an expression against multiple case clauses. If a case matches, the code inside that clause is executed.</p>

            <p>The case clause should finish with a break keyword. If no case matches but a default clause is included, the code inside default will be executed.</p>
            
            <p>Note: If break is omitted from the block of a case, the switch statement will continue to check against case values until a break is encountered or the flow is broken.</p>
            <pre>const food = 'salad';
 
                switch (food) {
                  case 'oyster':
                    console.log('The taste of the sea ü¶™');
                    break;
                  case 'pizza':
                    console.log('A delicious pie üçï');
                    break;
                  default:
                    console.log('Enjoy your meal');
                }
                 
                // Prints: Enjoy your meal</pre>
        </dd>
        </dl>
        <h1>Functions</h1>
        <dl>
          <dt>Functions</dt>
          <dd>Functions are reusable blocks of code that groups a sequence of statements together to exeecute a specific task</dd>
        
        <dt>Function Declatation</dt>
        <dd>A function declaration binds a function to a name, or an identifier.<br>
          A function declaration consists of:
          <ul>
            <li>the function keyword </li>
            <li>the name of the function followed by parentheses</li>
            <li>A function body, or the block of statements required to perform a specific task, enclosed in the function‚Äôs curly brackets, { }</li>
          </ul>
          <pre>
            function greetWorld() {
              console.log('Hello, World!');
              greetWorld(); // Output: Hello, World!
            }</pre>
        
        <dt>Calling a Function</dt>
        <dd>To call a function in your code, you type the function name followed by parentheses. The function call executes the function body, or all of the statements between the curly braces in the function declaration.</dd>
        <dt>Parameters and Arguments</dt>
        <dd>Parameters allow functions to accept input(s) and perform a task using the input(s). We use parameters as placeholders for information that will be passed to the function when it is called. When declaring a function add the names of the input values in the parentheses. When calling the function fill the values in in the parentheses to be passed to the function when it runs. <pre>function sayThanks(name) {
          console.log('Thank you for your purchase '+ name + '! We appreciate your business.');
        }
        sayThanks('Cole')</pre></dd>
        <dt>Default Parameters</dt>
        <dd>Default parameters allow parameters to have a predetermined value in case there is no argument passed into the function or if the argument is undefined when called. The = operator to assign the parameter name a default value<pre>function greeting (name = 'stranger') {
          console.log(`Hello, ${name}!`)
        }
         
        greeting('Nick') // Output: Hello, Nick!
        greeting() // Output: Hello, stranger!</pre></dd>
        <dt>Return</dt>
        <dd>Return passes information back from the function call. Without returning the value it will remain undefined even though the function calculated the input arguments correctly.<pre>function rectangleArea(width, height) {
          if (width < 0 || height < 0) {
            return 'You need positive integers to calculate area!';
          }
          return width * height;
        }</pre></dd>
        <dt>Helper Functions</dt>
        <dd>Helper functions return the value of another function within a function. This way we can use functions to break down logic into smaller, more manageable pieces and reuse them later. <pre>function multiplyByNineFifths(number) {
          return number * (9/5);
        };
         
        function getFahrenheit(celsius) {
          return multiplyByNineFifths(celsius) + 32;
        };
         
        getFahrenheit(15); // Returns 59</pre></dd>
        <dt>Function Expressions</dt>
        <dd>To define a function inside an expression, we can use the function keyword. In a function expression, the function name is usually omitted. A function with no name is called an anonymous function. A function expression is often stored in a variable in order to refer to it.<pre>const plantNeedsWater = function(day) {
          if (day === 'Wednesday') {
            return true;
          } else {
            return false;
          }
        }
        console.log(plantNeedsWater('Wednesday'))</pre></dd>
        <dt>Arrow Functions</dt>
        <dd>Arrow functions remove the need to type out the keyword function every time you need to create a function. Instead, you first include the parameters inside the ( ) and then add an arrow => that points to the function body surrounded in { } like this:</dd>
        <dt>Concise Body Arrow Functions</dt>
        <dd>
          <ul>
            <li>Functions that take only a single parameter do not need that parameter to be enclosed in parentheses. However, if a function takes zero or multiple parameters, parentheses are required.</li>
            <li>A function body composed of a single-line block does not need curly braces. Without the curly braces, whatever that line evaluates will be automatically returned. The contents of the block should immediately follow the arrow => and the return keyword can be removed. This is referred to as implicit return.</li>
          </ul>
          <pre>const squareNum = (num) => {
            return num * num;
          };</pre>
          refactors to 
          <pre>const squareNum = num => num * num;</pre>
        </dd>
      </dl>
      <h1>Arrays</h1>
      <dl>
        <dt>Array Literal</dt>
        <dd>
          Creates arrays by wrapping items in square brackets.
          <ul>
            <li>The array is represented by the square brackets [] and the content inside.</li>
            <li>Each content item inside an array is called an element.</li>
            <li>Elements inside an array can be different data types</li>
            <li>arrays can be storedd to variables</li>
            <li></li>
          </ul>
        </dd>
        <dt>Index</dt>
        <dd>The numbred position of each element inside an array. Access indexed elements with bracket notation
          <pre>const hello = 'Hello World';
            console.log(hello[6]);
            // Output: W</pre>
        </dd>
        <dt>Arrays with let and const</dt>
        <dd>Variables declared with the const keyword cannot be reassigned. However, elements in an array declared with const remain mutable. Meaning that we can change the contents of a const array, but cannot reassign a new array or a different value.</dd>
        <dt>The .length property</dt>
        <dd>returns the number of elements in an array or the number of characters in a string</dd>

        <dt>The .push() Method</dt>
        <dd>Adds elements to the end of an array. .push() can take a single argument or multiple arguments separated by commas. Notice that .push() changes, or mutates, itemTracker. You might also see .push() referred to as a destructive array method since it changes the initial array</dd>
        <dt>The .pop() Method</dt>
        <dd>Removes the last item from an array.</dd>
        <dt>The .shift() Method</dt>
        <dd>Removes and returns the first element in an array</dd>

        <dt>The .unshift() Method</dt>
        <dd>Takes an argument and adds it to the beginning of an array</dd>

        <dt>The .slice() method</dt>
        <dd>Extracts a selection of elements from an array. The selection includes start to end (but end is not included<pre>const animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];

          console.log(animals.slice(2));
          // expected output: Array ["camel", "duck", "elephant"]
          
          console.log(animals.slice(2, 4));
          // expected output: Array ["camel", "duck"]
          
          console.log(animals.slice(1, 5));
          // expected output: Array ["bison", "camel", "duck", "elephant"]
          
          console.log(animals.slice(-2));
          // expected output: Array ["duck", "elephant"]
          
          console.log(animals.slice(2, -1));
          // expected output: Array ["camel", "duck"]
          
          console.log(animals.slice());
          // expected output: Array ["ant", "bison", "camel", "duck", "elephant"]</pre></dd>

          <dt>The .indexOf() method</dt>
          <dd>.indexOf() takes an argument that matches an element in an arry and returns the index number of that element </dd>

          <dt>Nested Arrays</dt>
          <dd>Arrays can store other arrays. To access the data stored in nested arrays chain bracket notation. <pre>const nestedArr = [[1], [2, 3]];
 
            console.log(nestedArr[1]); // Output: [2, 3]
            console.log(nestedArr[1][0]); // Output: 2</pre></dd>
          <dt>the .splice() method</dt>
          <dd>Replaces portions of an array with new values. The first argument is the starting index of the splice. The second number is the number of indicies to be replaced, and all following values will be added at the indicated index. <pre>splice(start)
            splice(start, deleteCount)
            splice(start, deleteCount, item1)
            splice(start, deleteCount, item1, item2, itemN)</pre></dd>
      </dl>
      <h1>Loops</h1>
      <dl>
        <dt>For Loop</dt>
        <dd>Iterates an instruction a given number of times. A for loop contains three expressions separated by ; inside the parentheses:
          <ul>
            <li>an initialization starts the loop and can also be used to declare the iterator variable.</li>
            <li>a stopping condition is the condition that the iterator variable is evaluated against‚Äî if the condition evaluates to true the code block will run, and if it evaluates to false the code will stop.</li>
            <li>an iteration statement is used to update the iterator variable on each loop.</li>
          </ul>
          <pre>for (let counter = 0; counter < 4; counter++) {
            console.log(counter);
          }</pre>
        </dd>
        <dt>While Loop</dt>
        <dd>Evaluatses whether the while condition is true. When it's false, the loop stops.
          <pre>// A while loop that prints 1, 2, and 3
            let counterTwo = 1;
            while (counterTwo < 4) {
              console.log(counterTwo);
              counterTwo++;
            }</pre>
        </dd>
        <dt>Do...While Statements</dt>
        <dd>Similar to while loop but will run at least once, then continue running as long as the condition is true. <pre>const firstMessage = 'I will print!';
          const secondMessage = 'I will not print!'; 
           
          // A do while with a stopping condition that evaluates to false
          do {
           console.log(firstMessage)
          } while (true === false);
           
          // A while loop with a stopping condition that evaluates to false
          while (true === false){
            console.log(secondMessage)
          };</pre></dd>

          <dt>for‚Ä¶of loop</dt>
          <dd>A shorter, more readable for loop that removes some potential for syntax issues. It simply iterates over the objects in the array, string or array-like-object until it reaches the last item. It doesn't provide access to the index numbers within the block<br>A for loop would look like<pre>const hobbies = ['singing', 'eating', 'quidditch', 'writing'];
 
            for (let i = 0; i < hobbies.length; i++) {
              console.log(`I enjoy ${hobbies[i]}.`);
            }</pre>
          a for...of loop would look like this <pre>const hobbies = ['singing', 'eating', 'quidditch', 'writing'];
 
            for (const hobby of hobbies) {
              console.log(`I enjoy ${hobby}.`);
            }</pre></dd>
      </dl>

      <h1>Objects</h1>
      <dl>
        <dt>Object Literals</dt>
        <dd>Objects can be assigned to variables just like any JavaScript type. Use curly braces, {}, to designate an <i>object literal:</i>. Data is organized into key-value pairs. A key is like a variable name that points to a location in memory that holds a value. We make a key-value pair by writing the key‚Äôs name, or identifier, followed by a colon and then the value. We separate each key-value pair in an object literal with a comma (,). Keys are strings, but when we have a key that does not have any special characters in it, JavaScript allows us to omit the quotation marks:</dd>

        <dt>Accessing Properties</dt>
        <dd><h3>Dot notation</h3> returns the property associated with the key. If no key exists in the object it will return undefined<pre>let spaceship = {
          homePlanet: 'Earth',
          color: 'silver'
        };
        spaceship.homePlanet; // Returns 'Earth',
        spaceship.color; // Returns 'silver',</pre>
        <h3>Bracket notation</h3>
        Like using bracket notation with arrays. To use bracket notation to access an object‚Äôs property, we pass in the property name (key) as a string. must use bracket notation when accessing keys that have numbers, spaces, or special characters in them. Without bracket notation in these situations, our code would throw an error.
        <pre>
          let spaceship = {
            'Fuel Type': 'Turbo Fuel',
            'Active Duty': true,
            homePlanet: 'Earth',
            numCrew: 5
          };
          spaceship['Active Duty'];   // Returns true
          spaceship['Fuel Type'];   // Returns  'Turbo Fuel'
          spaceship['numCrew'];   // Returns 5
          spaceship['!!!!!!!!!!!!!!!'];   // Returns undefined
        </pre>
        With bracket notation you can also use a variable inside the brackets to select the keys of an object. This can be especially helpful when working with functions: 
        <pre>
          let returnAnyProp = (objectName, propName) => objectName[propName];
 
returnAnyProp(spaceship, 'homePlanet'); // Returns 'Earth'
        </pre>
      </dd>

      <dt>Poperty Assignment</dt>
      <dd>Once we‚Äôve defined an object, we‚Äôre not stuck with all the properties we wrote. Objects are mutable meaning we can update them after we create them!

        We can use either dot notation, ., or bracket notation, [], and the assignment operator, = to add new key-value pairs to an object or change an existing property. If the property already exists on the object, whatever value it held before will be replaced with the newly assigned value. If there was no property with that name, a new property will be added to the object.
        <pre>
          const spaceship = {type: 'shuttle'};
spaceship = {type: 'alien'}; // TypeError: Assignment to constant variable.
spaceship.type = 'alien'; // Changes the value of the type property
spaceship.speed = 'Mach 5'; // Creates a new key of 'speed' with a value of 'Mach 5'
        </pre>
        Remove property value pair with the delete keyword
        <pre>
          const spaceship = {
            'Fuel Type': 'Turbo Fuel',
            homePlanet: 'Earth',
            mission: 'Explore the universe' 
          };
           
          delete spaceship.mission;  // Removes the mission property
        </pre>
      </dd>

      <dt>Methods</dt>
      <dd>A function stored on an object is called a method. A property is what an object has. A Method is what it does. ES6 syntax doesn't require the colon and function keyword
        <pre>
          const alienShip = {
            invade: function () { 
              console.log('Hello! We have come to dominate your planet. Instead of Earth, it shall be called New Xaculon.')
            }
          };
          
          const alienShip = {
            invade () { 
              console.log('Hello! We have come to dominate your planet. Instead of Earth, it shall be called New Xaculon.')
            }
          };
        </pre>
      </dd>

      <dt>Nested Objects</dt>
      <dd>
        Objects can be nested within objects and each of those can have multiple properties, or even more objects within them. chain operators to access nested properties. We‚Äôll have to pay attention to which operator makes sense to use in each layer. 
        <pre>
          const spaceship = {
            telescope: {
               yearBuilt: 2018,
               model: '91031-XLT',
               focalLength: 2032 
            },
           crew: {
               captain: { 
                   name: 'Sandra', 
                   degree: 'Computer Engineering', 
                   encourageTeam() { console.log('We got this!') } 
                }
           },
           engine: {
               model: 'Nimbus2000'
            },
            nanoelectronics: {
                computer: {
                   terabytes: 100,
                   monitors: 'HD'
                },
               'back-up': {
                  battery: 'Lithium',
                  terabytes: 50
                }
           }
       }; 
        </pre>
      </dd>

      <dt>Pass By Reference</dt>
      <dd>Objects are passed by reference. This means when we pass a variable assigned to an object into a function as an argument, the computer interprets the parameter name as pointing to the space in memory holding that object. As a result, functions which change object properties actually mutate the object permanently (even when the object is assigned to a const variable).
        <pre>const spaceship = {
          homePlanet : 'Earth',
          color : 'silver'
        };
         
        let paintIt = obj => {
          obj.color = 'glorious gold'
        };
         
        paintIt(spaceship);
         
        spaceship.color // Returns 'glorious gold'</pre>
      </dd>

      <dt>For...in</dt>
      <dd>For, while, for...if and do while don't work on objects because objects aren't ordered. For...in Executes a block of code for each property in an object</dd>

      <dt>the this keyword</dt>
      <dd>Refers to the calling function</dd>

      <dt>This and arrow functions</dt>
      <dd>Arrow functions cannot be used with the this keyword. This is a global keyword and one of the limitations of arrow functions is that they inherently bind this to themselves, not the calling function. Using this with an arrow function will always return undefined. Use either the longhand
        <pre>const goat = {
          name: 'Billy',
          color: 'biege',
          giveDetails: function() {
            console.log(`${this.name} is a ${this.color} goat.`)
          }
        }</pre>
        or the shorthand function declaration 
        <pre>const goat = {
          name: 'Billy',
          color: 'biege',
          giveDetails(){
            console.log(`${this.name} is a ${this.color} goat.`)
          }
        }</pre>
      </dd>

      <dt>Privacy</dt>
      <dd>Javascript does not have built in privacy to prevent mutable objects from being altered in a way that breaks the code. Instead devs use _ to prepend properties that should not be changed</dd>

      <dt>Getters</dt>
      <dd>retrieve the value of properties in an object without altering them. Make sure to use a name for the getter method that is different from the property key (hence the _ prepending the key</dd>

      <dt>Setters</dt>
      <dd>Set the value of object properties</dd>

      <dt>Factory Functions</dt>

      </dl>


</body>
</html>